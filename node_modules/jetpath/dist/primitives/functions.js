import { opendir } from "node:fs/promises";
import path from "node:path";
import { cwd } from "node:process";
import { createServer } from "node:http";
import { Context, Log } from "./classes.js";
export function corsHook(options) {
    if (Array.isArray(options.allowMethods)) {
        options.allowMethods = options.allowMethods.join(",");
    }
    if (options.maxAge) {
        options.maxAge = String(options.maxAge);
    }
    options.keepHeadersOnError =
        options.keepHeadersOnError === undefined || !!options.keepHeadersOnError;
    return function cors(ctx) {
        ctx.set("Vary", "Origin");
        if (options.credentials === true) {
            ctx.set("Access-Control-Allow-Credentials", "true");
        }
        else {
            ctx.set("Access-Control-Allow-Origin", options.origin.join(","));
        }
        if (ctx.request.method !== "OPTIONS") {
        }
        else {
            if (options.maxAge) {
                ctx.set("Access-Control-Max-Age", options.maxAge);
            }
            if (options.privateNetworkAccess) {
                ctx.get("Access-Control-Request-Private-Network") &&
                    ctx.set("Access-Control-Allow-Private-Network", "true");
            }
            if (options.allowMethods) {
                ctx.set("Access-Control-Allow-Methods", options.allowMethods);
            }
            if (options.allowHeaders) {
                ctx.set("Access-Control-Allow-Headers", options.allowHeaders.join(","));
            }
            ctx.code = 204;
        }
    };
}
export const UTILS = {
    ctxPool: [],
    hooks: {},
    ae(cb) {
        try {
            cb();
            return true;
        }
        catch (error) {
            return false;
        }
    },
    set() {
        const bun = UTILS.ae(() => Bun);
        const deno = UTILS.ae(() => Deno);
        this.runtime = { bun, deno, node: !bun && !deno };
    },
    runtime: null,
    server(plugs) {
        let server;
        let serverelse;
        if (UTILS.runtime["node"]) {
            server = createServer((x, y) => {
                JetPath_app(x, y);
            });
        }
        if (UTILS.runtime["deno"]) {
            server = {
                listen(port) {
                    serverelse = Deno.serve({ port: port }, JetPath_app);
                },
                edge: false,
            };
        }
        if (UTILS.runtime["bun"]) {
            server = {
                listen(port) {
                    serverelse = Bun.serve({
                        port,
                        fetch: JetPath_app,
                    });
                },
                edge: false,
            };
        }
        const decorations = {};
        const edgePluginIdx = plugs.findIndex((plug) => plug.hasServer);
        if (edgePluginIdx > -1) {
            const edgePlugin = plugs.splice(edgePluginIdx, 1)[0];
            if (edgePlugin !== undefined && edgePlugin.hasServer) {
                const decs = edgePlugin._setup({
                    server: (!UTILS.runtime["node"] ? serverelse : server),
                    runtime: UTILS.runtime,
                    routesObject: _JetPath_paths,
                    JetPath_app: JetPath_app,
                });
                Object.assign(decorations, decs);
                if (edgePlugin.JetPathServer) {
                    server = edgePlugin.JetPathServer;
                    server.edge = true;
                }
            }
        }
        for (let i = 0; i < plugs.length; i++) {
            const decs = plugs[i]._setup({
                server: !UTILS.runtime["node"] ? serverelse : server,
                runtime: UTILS.runtime,
                routesObject: _JetPath_paths,
                JetPath_app: JetPath_app,
            });
            Object.assign(decorations, decs);
        }
        for (const key in decorations) {
            if (!UTILS.hooks[key]) {
                UTILS.hooks[key] = decorations[key];
            }
        }
        if (!server) {
            const edgeserver = plugs.find((plug) => plug.JetPathServer)?.JetPathServer;
            if (edgeserver !== undefined) {
                server = edgeserver;
            }
        }
        return server;
    },
};
UTILS.set();
export let _JetPath_paths = {
    GET: {},
    POST: {},
    HEAD: {},
    PUT: {},
    PATCH: {},
    DELETE: {},
    OPTIONS: {},
};
export const _JetPath_hooks = {};
class JetPathErrors extends Error {
    constructor(message) {
        super(message);
    }
}
export const _DONE = new JetPathErrors("done");
export const _OFF = new JetPathErrors("off");
const createCTX = (req, path, params, search) => {
    if (UTILS.ctxPool.length) {
        const ctx = UTILS.ctxPool.shift();
        ctx._7(req, path, params, search);
        return ctx;
    }
    const ctx = new Context();
    Object.assign(ctx.app, UTILS.hooks);
    ctx._7(req, path, params, search);
    return ctx;
};
const createResponse = (res, ctx, four04) => {
    _JetPath_hooks["cors"]?.(ctx);
    if (!UTILS.runtime["node"]) {
        if (ctx?.code === 301 && ctx._2?.["Location"]) {
            UTILS.ctxPool.push(ctx);
            return Response.redirect(ctx._2?.["Location"]);
        }
        if (ctx?._3) {
            UTILS.ctxPool.push(ctx);
            return new Response(ctx?._3, {
                status: 200,
                headers: ctx?._2,
            });
        }
        UTILS.ctxPool.push(ctx);
        return new Response(ctx?._1 || (four04 ? "Not found" : undefined), {
            status: (four04 && 404) || ctx.code,
            headers: ctx?._2,
        });
    }
    if (ctx?._3) {
        res.writeHead(ctx?.code, ctx?._2);
        UTILS.ctxPool.push(ctx);
        return ctx._3.pipe(res);
    }
    res.writeHead((four04 && 404) || ctx.code, ctx?._2 || { "Content-Type": "text/plain" });
    res.end(ctx?._1 || (four04 ? "Not found" : undefined));
    UTILS.ctxPool.push(ctx);
};
const JetPath_app = async (req, res) => {
    const paseredR = URLPARSER(req.method, req.url);
    let off = false;
    let ctx;
    if (paseredR) {
        const r = paseredR[0];
        ctx = createCTX(req, paseredR[3], paseredR[1], paseredR[2]);
        try {
            await _JetPath_hooks["PRE"]?.(ctx);
            await r(ctx);
            await _JetPath_hooks["POST"]?.(ctx);
            return createResponse(res, ctx);
        }
        catch (error) {
            if (error instanceof JetPathErrors) {
                if (error.message !== "off") {
                    return createResponse(res, ctx);
                }
                else {
                    off = true;
                }
            }
            else {
                try {
                    await _JetPath_hooks["ERROR"]?.(ctx, error);
                    return createResponse(res, ctx);
                }
                catch (error) {
                    return createResponse(res, ctx);
                }
            }
        }
    }
    if (!off) {
        if (req.method === "OPTIONS") {
            return createResponse(res, createCTX(req, ""));
        }
        return createResponse(res, createCTX(req, ""), true);
    }
    else {
        return new Promise((r) => {
            ctx._5 = () => {
                r(createResponse(res, ctx));
            };
        });
    }
};
const Handlerspath = (path) => {
    if (path.includes("hook__")) {
        return path.split("hook__")[1];
    }
    path = path.split("_");
    const method = path.shift();
    path = "/" + path.join("/");
    path = path.split("$$");
    path = path.join("/?");
    path = path.split("$0");
    path = path.join("/*");
    path = path.split("$");
    path = path.join("/:");
    if (/(GET|POST|PUT|PATCH|DELETE|OPTIONS)/.test(method)) {
        return [method, path];
    }
    return;
};
const getModule = async (src, name) => {
    try {
        const mod = await import(path.resolve(src + "/" + name));
        return mod;
    }
    catch (error) {
        return String(error);
    }
};
export async function getHandlers(source, print, errorsCount = undefined) {
    source = source || cwd();
    source = path.resolve(cwd(), source);
    const dir = await opendir(source);
    for await (const dirent of dir) {
        if (dirent.isFile() && dirent.name.endsWith(".jet.js")) {
            if (print) {
                Log.info("Loading routes at " + source + "/" + dirent.name);
            }
            try {
                const module = await getModule(source, dirent.name);
                if (typeof module !== "string") {
                    for (const p in module) {
                        const params = Handlerspath(p);
                        if (params) {
                            if (typeof params !== "string") {
                                module[p].method = params[0];
                                module[p].path = params[1];
                                _JetPath_paths[params[0]][params[1]] = module[p];
                            }
                            else {
                                if ("POST-PRE-ERROR".includes(params)) {
                                    _JetPath_hooks[params] = module[p];
                                }
                            }
                        }
                    }
                }
                else {
                    if (dirent.name.endsWith(".jet.js")) {
                        if (!errorsCount) {
                            errorsCount = [];
                        }
                        errorsCount.push({
                            file: dirent.path + "/" + dirent.name,
                            error: module,
                        });
                    }
                }
            }
            catch (error) {
                if (dirent.name.endsWith(".jet.js")) {
                    if (!errorsCount) {
                        errorsCount = [];
                    }
                    errorsCount.push({
                        file: dirent.path + "/" + dirent.name,
                        error: String(error),
                    });
                }
            }
        }
        if (dirent.isDirectory() &&
            dirent.name !== "node_modules" &&
            dirent.name !== ".git") {
            errorsCount = await getHandlers(source + "/" + dirent.name, print, errorsCount);
        }
    }
    return errorsCount;
}
export function validator(schema, data) {
    const out = {};
    let errout = "";
    if (typeof data !== "object")
        throw new Error("invalid data => " + data);
    for (const [prop, value] of Object.entries(schema || {})) {
        const { err, type, required, RegExp, validator } = value;
        if (data[prop] === undefined || data[prop] === null) {
            if (!required) {
                continue;
            }
            else {
                errout = err || `${prop} is required`;
                break;
            }
        }
        if (typeof type === "string" && type !== typeof data[prop]) {
            if (type !== "file") {
                errout = err || `${prop} type is invalid '${data[prop]}' `;
                break;
            }
        }
        if (typeof RegExp === "object" && !RegExp.test(data[prop])) {
            errout = err || `${prop} is invalid`;
            break;
        }
        if (typeof validator === "function") {
            const v = validator(data[prop]);
            if (v !== true) {
                errout = err || typeof v === "string" ? v : `${prop} must is invalid`;
                break;
            }
        }
        out[prop] = data[prop];
    }
    if (errout)
        throw new Error(errout);
    return out;
}
const URLPARSER = (method, url) => {
    const routes = _JetPath_paths[method];
    if (!UTILS.runtime["node"]) {
        url = url.slice(url.indexOf("/", 7));
    }
    if (routes[url]) {
        return [routes[url], {}, {}, url];
    }
    const search = {}, params = {};
    let path, handler;
    for (const pathR in routes) {
        let breaked = false;
        if (pathR.includes(":")) {
            const urlFixtures = url.split("/");
            const pathFixtures = pathR.split("/");
            if (urlFixtures.length !== pathFixtures.length) {
                continue;
            }
            for (let i = 0; i < pathFixtures.length; i++) {
                if (!pathFixtures[i].includes(":") &&
                    urlFixtures[i] !== pathFixtures[i]) {
                    breaked = true;
                    break;
                }
            }
            if (breaked) {
                continue;
            }
            for (let i = 0; i < pathFixtures.length; i++) {
                const px = pathFixtures[i];
                if (px.includes(":")) {
                    params[px.split(":")[1]] = urlFixtures[i];
                }
            }
            path = pathR;
            handler = routes[path];
            break;
        }
        if (pathR.includes("*")) {
            const Ried = pathR.slice(0, pathR.length - 1);
            if (url.includes(Ried)) {
                params.extraPath = url.slice(Ried.length);
                path = pathR;
                handler = routes[path];
                break;
            }
        }
    }
    const uio = url.indexOf("/?");
    if (uio > -1) {
        path = url.slice(0, uio + 2);
        if (url.includes("=")) {
            const sraw = url.slice(path.length).split("=");
            for (let s = 0; s < sraw.length; s = s + 2) {
                search[sraw[s]] = sraw[s + 1];
            }
        }
        if (routes[path]) {
            handler = routes[path];
        }
    }
    if (handler) {
        return [handler, params, search, path];
    }
};
export const compileUI = (UI, options, api) => {
    const globalHeaders = JSON.stringify(options?.globalHeaders || {
        Authorization: "Bearer ****",
    });
    return UI.replace("'{JETPATH}'", `\`${api}\``)
        .replaceAll("{JETPATHGH}", `${globalHeaders}`)
        .replaceAll("{NAME}", options?.apiDoc?.name || "JethPath API Doc")
        .replaceAll("JETPATHCOLOR", options?.apiDoc?.color || "#007bff")
        .replaceAll("{LOGO}", options?.apiDoc?.logo ||
        "https://raw.githubusercontent.com/Uiedbook/JetPath/main/icon-transparent.webp")
        .replaceAll("{INFO}", options?.apiDoc?.info || "This is a JethPath api preview.");
};
export const compileAPI = (options) => {
    let handlersCount = 0;
    let compiledAPIArray = [];
    let compiledRoutes = [];
    const globalHeaders = options?.globalHeaders || {};
    for (const method in _JetPath_paths) {
        const routesOfMethod = _JetPath_paths[method];
        if (routesOfMethod && Object.keys(routesOfMethod).length) {
            for (const route in routesOfMethod) {
                const validator = routesOfMethod[route];
                const body = validator.body;
                const inialHeader = {};
                Object.assign(inialHeader, validator?.headers || {}, globalHeaders);
                const headers = [];
                for (const name in inialHeader) {
                    headers.push(name + ":" + inialHeader[name]);
                }
                let bodyData = undefined;
                if (body) {
                    bodyData = {};
                    for (const keyOfBody in body) {
                        bodyData[keyOfBody] =
                            body[keyOfBody]?.defaultValue ||
                                body[keyOfBody]?.inputType ||
                                "text";
                    }
                }
                const api = `\n
${method} ${options?.APIdisplay === "UI"
                    ? "[--host--]"
                    : "http://localhost:" + (options?.port || 8080)}${route} HTTP/1.1
${headers.length ? headers.join("\n") : ""}\n
${(body && method !== "GET" ? method : "") ? JSON.stringify(bodyData) : ""}\n${validator?.["info"] ? "#" + validator?.["info"] + "-JETE" : ""}
###`;
                const low = sorted_insert(compiledRoutes, route);
                compiledRoutes.splice(low, 0, route);
                compiledAPIArray.splice(low, 0, api);
                handlersCount += 1;
            }
        }
    }
    const compileAPIString = compiledAPIArray.join("");
    return [handlersCount, compileAPIString];
};
const sorted_insert = (paths, path) => {
    let low = 0;
    let high = paths.length - 1;
    for (; low <= high;) {
        const mid = Math.floor((low + high) / 2);
        const current = paths[mid];
        if (current < path) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
    return low;
};
